# Crypto / EpsilonDH

En el código vemos que hay un algoritmo similar a Diffie-Hellman pero con la diferencia de que la base usada no es un número entero, sino un objeto de la nueva clase Epsilon.

Acerca de la clase podemos decir que es una tupla (a,bε) o más bien un binomio de la forma a+bε.

Métodos de la clase

__init__: Es el constructor de clase, toma dos parametros, a y b.

\_\_add\_\_: Es la operación suma del binomio, que se mantiene igual al álgebra convencional (a,bε) + (c,dε) = (a+c,(b+d)ε).

\_\_radd\_\_: Es la operación suma reflexiva (esto es para el manejo del operador + en python cuando se suma un objeto Epsilon con algun entero).

\_\_mul\_\_: Es la operación multiplicación del binomio, pero con algo particular.

\_\_rmul\_\_: Es la operación multiplicación reflexiva (esto es para el manejo del operador * en python cuando se multiplica un objeto Epsilon por algun entero).

\_\_mod\_\_: Es la operación módulo del binomio, se define como (a,bε) % c = (a%c,bε%c)

\_\_repr\_\_: Es la representación de la tupla (a+bε).

getRandomBits: Un método propio de la clase, con Epsilon.getRandomBits(n) se crea un objeto Epsilon con coeficientes de n dígitos.


``` python3 
# chall.py
def powm(b, e, m):
    r = 1
    while e > 1:
        if e & 1:
            print("right")
            r = (r * b) % m
        b = (b * b)  % m
        e >>= 1
    return (b * r) % m

ɛ = Epsilon(0, 1)
g = ɛ.getRandomBits(1024)
m = bytes_to_long(flag)
assert m < p
A = powm(g, m, p)
```

Podemos ver como se usa crea el objeto Epsilon g, la bandera m y el numero primo p para realizar una exponenciacion modular rapida en la funcion powm. 

```
cat out.txt
p = 173924944755645003178406095718617168013285320974193311533464918516351624141198287888308296721497553891802368640344837769848433705383843820088678374708528763495103734488139368870389319280613181418960926879728892929013723036956818870578758055144789952650214552781344528622703875374067812710366180881422848078127
g = 153222010878956025592659771364999461265827693159532862299380012549533704470078014065110463612108844661289052080113198166134196684645743591092035461757997498335465019478118882739217108862526250347939116529661007420054504044554198442479469991584947626223020239910145162698053768142977329057860163194054350707249 + 172891042743500566967040288858220451145776247635832845268756172370398885506225014595399937064138727095012954778403481826951857306135326675358326250562011754152669045113179084291737802426967956129601732530346663460456772733886633658030480267226610996560624379249886941665142384623344612516572694197005870648544ɛ
A = 111358852433093434730054197107140594544307303976075171645711474646957878889456280742672183479878216988442037548855367380131019369757301409440037291726826948896290153981733240859717678222235993520619121828503359668550259222802623131077882382174117682287404839404525320091636778728025592053329591735052259548204 + 45354415949210290456746549581237886628185346518296265188224888250560968013577364380436312628842962917052795341010011570997705657164666282067908433629612354440756444902895692385443905786057605548586533595209894409891955713650856537806150873335015064767898088756645985769501205659617651498842444073593828856739ɛ
```

Tenemos p, g y A y debemos obtener m sabiendo que gᵐ mod p = A.

Para eso revisaremos la funcion de multiplicacion del binomio:

``` python3
   def __mul__(self, other):
        if type(other) == int: other = Epsilon(other, 0)
        return Epsilon(self.a * other.a, self.a * other.b + other.a * self.b)
```

### Analisis de la multiplicacion e idempotencia

Como sabemos la multiplacion de dos binomios lineales da como resultado un trinomio, donde la variable (en este caso ε) deberia estar elevada al cuadrado en un monomio, pero esto no se cumple, la clase no tiene alguna forma de manejar estos trinomios, por lo que se puede decir que en este tipo de algebra ε es idempotente (ε²=0).

Se esperaria que: (a + bε) * (c + dε) = ac + adε + bcε + bdε²

Entonces debería quedar que: (a,bε) * (c,dε) = (ac,(ad+bc+bdε)ε) 

Pero dada la definición de la función aquí quedaría: (a,bε) * (c,dε) = (ac,(ac+bd)ε); por lo tanto ε²=0

Lo mas importante aqui es que, dado el teorema del binomio de Newton: (a + b)ⁿ = ∑ₖ₌₀ⁿ

![binomio](https://github.com/user-attachments/assets/0da09a62-4ad0-45ab-8f92-7f4eb161613a)

Pero gracias a que εⁿ=0; n > 1 se reduce todo a los dos primeros monomios:

```
(a+bε)² = a² + 2abε 

(a+bε)³ = a³ + 3a²bε 

(a+bε)⁴ = a⁴ + 4a³bε

(a+bε)ⁿ = aⁿ + naⁿ⁻¹bε
```

### Explotando la debilidad del sistema

Encontrar m por fuerza bruta para un modulo primo p de 1024 dígitos no es viable, pero con un poco de matemáticas podemos ver otra salida. Extraeremos las partes de A y de g:

``` python3
from Crypto.Util.number import inverse, long_to_bytes

p = 173924944755645003178406095718617168013285320974193311533464918516351624141198287888308296721497553891802368640344837769848433705383843820088678374708528763495103734488139368870389319280613181418960926879728892929013723036956818870578758055144789952650214552781344528622703875374067812710366180881422848078127


g_str = '153222010878956025592659771364999461265827693159532862299380012549533704470078014065110463612108844661289052080113198166134196684645743591092035461757997498335465019478118882739217108862526250347939116529661007420054504044554198442479469991584947626223020239910145162698053768142977329057860163194054350707249 + 172891042743500566967040288858220451145776247635832845268756172370398885506225014595399937064138727095012954778403481826951857306135326675358326250562011754152669045113179084291737802426967956129601732530346663460456772733886633658030480267226610996560624379249886941665142384623344612516572694197005870648544ɛ'

A_str = '111358852433093434730054197107140594544307303976075171645711474646957878889456280742672183479878216988442037548855367380131019369757301409440037291726826948896290153981733240859717678222235993520619121828503359668550259222802623131077882382174117682287404839404525320091636778728025592053329591735052259548204 + 45354415949210290456746549581237886628185346518296265188224888250560968013577364380436312628842962917052795341010011570997705657164666282067908433629612354440756444902895692385443905786057605548586533595209894409891955713650856537806150873335015064767898088756645985769501205659617651498842444073593828856739ɛ'


g_parts = g_str.split(' + ')
g_a = int(g_parts[0].strip())
g_b = int(g_parts[1].strip()[:-1]) 

A_parts = A_str.split(' + ')
A_a = int(A_parts[0].strip())
A_b = int(A_parts[1].strip()[:-1])  
```

Por todo lo anteriormente explicado:
```
  A = gᵐ mod p =  (g_aᵐ mod p, m ⋅ g_a⁽ᵐ⁻¹⁾ ⋅ g_b mod p) 

```

Sacamos dos valores k y d:
```
  k = m ⋅ g_a⁽ᵐ⁻¹⁾ ⋅ g_b mod p ⋅ g_a) mod p  
  k = m ⋅ g_b ⋅ g_aᵐ (mod p) 

  d = g_aᵐ mod p ⋅ g_b) mod p
  d = g_b ⋅ g_aᵐ mod p
```

``` python3
k = (A_b * g_a) % p                                                     
d = (A_a * g_b) % p  
```

Como vemos k y d comparten los factores g_b y g_aᵐ, o sea que 'dividir' k por d, o lo que es lo mismo, multiplicar k por el inverso multiplicativo de d en modulo p, nos permtiria simplificar y obtener m:
```
 k * d⁻¹ mod p = m 
```

Listo, con esto solo queda convertir el numero m a bytes y obtener la flag:
``` python3
# solve.py
from Crypto.Util.number import inverse, long_to_bytes

p = 173924944755645003178406095718617168013285320974193311533464918516351624141198287888308296721497553891802368640344837769848433705383843820088678374708528763495103734488139368870389319280613181418960926879728892929013723036956818870578758055144789952650214552781344528622703875374067812710366180881422848078127


g_str = '153222010878956025592659771364999461265827693159532862299380012549533704470078014065110463612108844661289052080113198166134196684645743591092035461757997498335465019478118882739217108862526250347939116529661007420054504044554198442479469991584947626223020239910145162698053768142977329057860163194054350707249 + 172891042743500566967040288858220451145776247635832845268756172370398885506225014595399937064138727095012954778403481826951857306135326675358326250562011754152669045113179084291737802426967956129601732530346663460456772733886633658030480267226610996560624379249886941665142384623344612516572694197005870648544ɛ'

A_str = '111358852433093434730054197107140594544307303976075171645711474646957878889456280742672183479878216988442037548855367380131019369757301409440037291726826948896290153981733240859717678222235993520619121828503359668550259222802623131077882382174117682287404839404525320091636778728025592053329591735052259548204 + 45354415949210290456746549581237886628185346518296265188224888250560968013577364380436312628842962917052795341010011570997705657164666282067908433629612354440756444902895692385443905786057605548586533595209894409891955713650856537806150873335015064767898088756645985769501205659617651498842444073593828856739ɛ'


g_parts = g_str.split(' + ')
g_a = int(g_parts[0].strip())
g_b = int(g_parts[1].strip()[:-1])  # Remover la 'ɛ' al final

A_parts = A_str.split(' + ')
A_a = int(A_parts[0].strip())
A_b = int(A_parts[1].strip()[:-1])  # Remover la 'ɛ' al final

# Calcular k y d
k = (A_b * g_a) % p
d = (A_a * g_b) % p

# Hallar el inverso multiplicativo de d en mod p
d_inv = inverse(d, p)

# Hallar la flag
m = (k * d_inv) % p

# Decodificar la flag
flag_bytes = long_to_bytes(m)

try:
    flag = flag_bytes.decode('utf-8')
    print('Flag:', flag)
except UnicodeDecodeError:
    print('Fallo al decodificar, bytes obtenidos: ')
    print(flag_bytes)
```

```
 python3 solve.py
Flag: wwf{3psil0n_1s_k1dn4_0P}
```

`wwf{3psil0n_1s_k1dn4_0P}`
 





